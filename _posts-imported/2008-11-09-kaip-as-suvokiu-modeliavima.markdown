---
layout: post
title: !binary |-
  S2FpcCBhxaEgc3V2b2tpdSBtb2RlbGlhdmltxIU=
wordpress_id: 197
wordpress_url: !binary |-
  aHR0cHM6Ly9qYWt1dC5pcy8/cD0xOTc=
date: 2008-11-09 20:22:06.000000000 +00:00
---
Modeliavimas yra veiksmas. Pažymėkime A - objektą, skirtą patenkinti kokius nors poreikius. Modeliavimas priklauso veiksmų rinkiniui, kurio tikslas yra sukurti A. Modeliavimas skiriasi nuo prototipavimo tuo, kad modeliuojamam objektui daromi dažnesni, smulkesni pakeitimai. Modeliavimas prasideda pasirinkus pradinį modelį: medžiagų rinkinį, kokį nors daiktą, t.y. visiškai bet ką, bet kokią formą, nors, aišku, jis pasirenkamas spėjimo būdu, taip, kad po to modeliuoti būtų paprasčiau. Modeliavimas vyksta, kai modeliuotojas gauna teiginius apie A ir modifikuoja esamą modelį, taip, kad tie teiginiai, pritaikyti modeliui, išliktų teisingi. Modeliavimo forma nenaudojama tada, kai modelis telpa modeliuotojo galvoje. Kuo modelis sudėtingesnis, kuo mažiau teiginių apie jį yra žinoma, tuo daugiau nutinka modifikacijų, kurios yra vėliau atšaukiamos. Galima išskirti du kraštutinius atvejus: kai modeliavimas pradedamas gavus visus teiginius apie A ir kai modeliavimas pradedas gavus pirmąjį teiginį apie A. Realiuose modeliavimo procesuose yra balansuojama tarp jų dviejų. Šis balansavimas yra funkcija kintamaisiais, turinčiais prioritetą. Kuo daugiau kintamųjų su dideliais prioritetais, tuo funkcija sudėtingesnė. Kuo tiksliau yra įvardyti kintamieji ir jų prioritetai, tuo funkcija yra teisingesnė, tuo jos parinktas balansas yra efektyvesnis ir tuo greičiau yra sukuriamas A.

Priartėkime prie realybės. Tarkime, kad A yra kokia nors programinė įranga. Jos modeliavime tie du kraštutiniai atvejai atitinkamai vadinami "the waterfall method" ir "Xtreme programming". Antrasis atvejis leidžia greičiau gauti pirmą modelį. To privalumai - galima greičiau ištaisyti klaidas, daryti pakeitimus, greičiau reaguojama į pasikeitusius poreikius (gavus teiginius, prieštaraujančius ankstesniems teiginiams). Pirmasis atvejis leidžia sunaudoti mažiau resursų modeliuojant. Taigi jis tuo parankesnis, kuo mažesnė tikimybė, kad gaunami teiginiai nebus vėliau pakeisti. Programinės įrangos modeliavimas iš tikrųjų yra kodo rašymas kokia (arba net kokiom) nors programavimo kalba. Daugumoje realių tokių modeliavimų programavimas nėra viskas. Į pagalbą prilipdoma įvairių procesų, pvz. teiginių formalizavimo į reikalavimus, architektūros kūrimo, integravimo, testavimo, dokumentavimo (aprašymų kūrimo), klaidų taisymo. Kitaip tariant, vyksta daug papildomų dalykų ir tas vienintelis tikslinis, reikalingas, panaudojamas dalykas sudaro ne didžiausią dalį. Kuo ta dalis yra mažesnė, tuo A sukūrimas yra sudėtingesnis. Kad A sukūrimas būtų mažiau sudėtingas, pasirenkama abstraktesnė programavimo kalba. Pavyzdžiai: C kodas virš x86 instrukcijų (darbą atlieka C kompiliatorius, pvz. GCC); Python kodas virš - Java VM (ar CPython VM) bytecode (darbą atlieka Jython (ar CPython interpretatorius)). Programavimas tiesiogiai priklauso tik nuo architektūros. Architektūros kūrimas yra teiginius apie A atitinkantis abstrahavimas, kurio aukštesniame lygyje - įvairūs aprašymai diagramos, žemesniame lygyje - programavimo kalba, jos platforma (ta pačia programavimo kalba parašytos bibliotekos, kitos sistemos, kurias reikės integruoti). Būtent architektūra ir išpildo turimus teiginius apie A. Čia pastebime panašumą tarp pvz. C kompiliatoriaus ir programuotojo veiksmų. Taigi, kad abstraktesnė programavimo kalbą yra ta, kuri panašesnė į minėtuosius įvairius aprašymus, diagramas. O kas iš tikrųjų yra tie aprašymai ir diagramos? Tai yra struktūrizuotas A aprašymas, skirtas programuotojui. Turėdamas tik teiginius apie A užtruktų daug ilgiau, kol sukurtų A. Čia pastebime panašumą tarp architektūros kūrimo ir programavimo - abu procesai yra modeliavimas. Dabar peršasi noras, kad antrąjį procesą - programavimą - atliktų ne žmogus, mašina. Juk C kompiliatorius irgi kažkada leido atsisakyti mašininį kodą kuriančių žmonių. Šis noras jau pradėjo pildytis: populiarėja DSL (Domain Specific Language) metodo naudojimas, vystomos UML tipo priemonės. Tačiau kolkas šie būdai dar neleidžia atsisakyti programuotojo. Pirmuoju būdu kiekvienam A reikia vis kurti kitokį DSL ir jai vykdyti skirtos platformos. Antruoju tos priemonės yra griozdiškos ir nepriartėja prie realybės, nes joms nekuriamos kodą vykdančios platformos. Bet yra dar vienas būdas - panašesnis į antrąjį, tačiau turintis veikiančią platformą. Tai yra <a href="http://en.wikipedia.org/wiki/Business_Process_Modeling">BPM</a>, <a href="http://en.wikipedia.org/wiki/Semantic_Web_Rule_Language">SWRL</a>, <a href="http://en.wikipedia.org/wiki/Rdf">RDF</a>, <a href="http://en.wikipedia.org/wiki/Xml_schema">XML schema</a> tipo <a href="http://en.wikipedia.org/wiki/Semantic_Web_Stack">semantinės</a> priemonės.

Kolkas jos dar tik gimsta ir auga gūdžiuose, buzzword'ų pilnuose miškuose, niekas nežino, kada ir kas į saulės šviesą prieš mus pasirodyti išeis pirmasis. Kolkas atrodo, kad savo saulės lopinėlį tame miške jau surado <a href="http://en.wikipedia.org/wiki/Semantic_web">semantic web</a> ir business process modelling. Nors dar kažko trūksta. Kas žino ar jos kirs mišką, ir jei kirs, tai kiek kirs. Mums džiugiausia, aišku, būtų, kad kas nors išdrįstų išeiti į atvirą erdvę iš ten kur dabar tūno ir padarytų stebuklingą progresą esamose srityse. O gal visgi lemta tradicinėms Desktop aplikacijoms grimzti į užmarštį ir apželti miškais tuo tarpu plečiantis tiems kirtimams?
